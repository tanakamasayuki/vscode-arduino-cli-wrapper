<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Arduino CLI Boards Selector</title>
  <style>
    :root {
      color-scheme: light dark;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      margin: 20px;
      line-height: 1.5;
    }

    h1 {
      font-size: 1.25rem;
      margin: 0 0 10px;
    }

    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    /* Shared style for search text boxes */
    .textbox {
      padding: 8px 10px;
      font-size: 1rem;
    }

    #q {
      flex: 1 1 260px;
    }

    #status {
      font-size: .92rem;
      opacity: .8;
    }

    ul {
      list-style: none;
      padding: 0;
      margin: 12px 0 0;
    }

    li {
      padding: 8px 10px;
      border: 1px solid #ccc;
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .name {
      font-weight: 600;
    }

    .fqbn {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      opacity: .9;
    }

    .empty {
      opacity: .7;
      font-style: italic;
    }

    .error {
      color: #b00020;
    }
  </style>
  <!-- This page expects board_details.json generated by run.php -->
</head>

<body>
  <h1>Arduino CLI Boards Selector</h1>
  <div class="controls">
    <input id="q" class="textbox" type="search" placeholder="Filter (name or FQBN)" autocomplete="off" />
    <div id="status">Loading...</div>
  </div>
  <ul id="list" aria-live="polite"></ul>
  <div id="config" style="margin-top:16px;"></div>
  <div id="summaryBottom" class="fqbn" style="margin-top:24px; padding-top:8px; border-top:1px solid #ccc;"></div>

  <script>
    (function () {
      'use strict';
      const DATA_URL = 'https://tanakamasayuki.github.io/arduino-cli-helper/board_details.json';
      const LIB_URL = 'https://tanakamasayuki.github.io/arduino-cli-helper/libraries.json';
      const q = document.getElementById('q');
      const status = document.getElementById('status');
      const list = document.getElementById('list');

      /** @type {{fqbn:string,name:string,search:string,el:HTMLLIElement}[]} */
      let items = [];
      /** @type {Record<string, {name?:string, version?:string, config_options?: any[], package_url?: string}>} */
      let dataMap = {};
      /** @type {Array<any>|null} */
      let libsCache = null;
      /** @type {Map<string,string|true>} */
      const selectedLibs = new Map();
      /** @type {Array<{key:string,val:string}>|null} */
      window.__OPT_PAIRS = null; // pairs parsed from extFqbn (key=value)
      // Defer any YAML templating until init message arrives with profile block
      try { window.__INIT_PENDING__ = true; window.__USER_CHANGED_OPTIONS__ = false; } catch (_) { }

      function setStatus(text, isError = false) {
        status.textContent = text;
        status.className = isError ? 'error' : '';
      }

      function render(data) {
        dataMap = data || {};
        const entries = Object.entries(dataMap).map(([fqbn, v]) => ({
          fqbn,
          name: (v && typeof v.name === 'string') ? v.name : '',
        }));
        entries.sort((a, b) => a.name.localeCompare(b.name, 'en'));
        list.innerHTML = '';
        items = entries.map(({ fqbn, name }) => {
          const li = document.createElement('li');
          const nameEl = document.createElement('div');
          nameEl.className = 'name';
          nameEl.textContent = name || '(No name)';
          const fqbnEl = document.createElement('div');
          fqbnEl.className = 'fqbn';
          fqbnEl.textContent = fqbn;
          li.appendChild(nameEl);
          li.appendChild(fqbnEl);
          li.addEventListener('click', () => {
            try { window.__USER_CHANGED_OPTIONS__ = true; window.__INIT_PENDING__ = false; } catch (_) { }
            q.value = fqbn;
            applyFilter();
          });
          list.appendChild(li);
          return { fqbn, name, search: (fqbn + ' ' + name).toLowerCase(), el: li };
        });


        setStatus(`${items.length} items`);
      }

      function applyFilter() {
        const rawNeedle = q.value.trim();
        const needle = rawNeedle.toLowerCase();
        let exact = rawNeedle && Object.prototype.hasOwnProperty.call(dataMap, rawNeedle) ? rawNeedle : null;
        // Fallback: if user pasted/extFQBN like vendor:arch:board:opt=val, use base vendor:arch:board
        if (!exact && rawNeedle) {
          const parts = rawNeedle.split(':');
          if (parts.length >= 4) {
            const base = parts.slice(0, 3).join(':');
            if (Object.prototype.hasOwnProperty.call(dataMap, base)) {
              exact = base;
            }
          }
        }
        if (!needle) {
          items.forEach(it => { it.el.style.display = ''; });
          setStatus(`${items.length} items`);
          renderConfig(null, null);
          return;
        }
        if (exact) {
          let visible = 0;
          items.forEach(it => {
            const match = it.fqbn === exact;
            it.el.style.display = match ? '' : 'none';
            if (match) visible++;
          });
          setStatus(`${visible} item(s) (exact match)`);
          try {
            window.__INIT_PENDING__ = false;
            if (!window.__CURRENT_BASEFQBN__) window.__CURRENT_BASEFQBN__ = exact;
            if (!window.__CURRENT_EXTFQBN__) window.__CURRENT_EXTFQBN__ = exact;
          } catch (_) { }
          renderConfig(exact, dataMap[exact] || null);
        } else {
          let visible = 0;
          items.forEach(it => {
            const match = it.search.includes(needle);
            it.el.style.display = match ? '' : 'none';
            if (match) visible++;
          });
          setStatus(`${visible} / ${items.length} items`);
          renderConfig(null, null);
        }
      }

      // VS Code API getter: acquire exactly once to avoid errors
      function getVsCodeApi() {
        try {
          if (window.__VSCODE_API__) return window.__VSCODE_API__;
          if (typeof acquireVsCodeApi === 'function') {
            window.__VSCODE_API__ = acquireVsCodeApi();
            return window.__VSCODE_API__;
          }
        } catch (_) { /* ignore */ }
        return null;
      }

      function renderConfig(fqbn, detail) {
        const root = document.getElementById('config');
        root.innerHTML = '';
        const summaryBottom = document.getElementById('summaryBottom');
        summaryBottom.textContent = '';
        if (!fqbn || !detail) return;

        const title = document.createElement('h2');
        title.style.fontSize = '1.1rem';
        title.textContent = `Config Options: ${detail.name || ''} (${fqbn})`;
        root.appendChild(title);

        // Package URL (show above FQBN summary, no link)
        const pkgUrl = (detail && typeof detail.package_url === 'string') ? detail.package_url : '';
        if (pkgUrl) {
          const p = document.createElement('div');
          p.style.margin = '4px 0 8px';
          p.textContent = 'Package URL: ' + pkgUrl;
          root.appendChild(p);
        }

        // Summary shown just before options (below package URL)
        const summaryTop = document.createElement('div');
        summaryTop.className = 'fqbn';
        summaryTop.style.margin = '8px 0';
        root.appendChild(summaryTop);

        // YAML output UI (placed above options)
        const yamlWrap = document.createElement('div');
        yamlWrap.style.margin = '12px 0';
        const yamlLabel = document.createElement('div');
        yamlLabel.textContent = 'sketch.yaml (template)';
        yamlLabel.style.fontWeight = '600';
        yamlLabel.style.margin = '8px 0 4px';
        const yamlBox = document.createElement('textarea');
        yamlBox.id = 'yamlBox';
        yamlBox.rows = 15;
        yamlBox.style.width = '100%';
        yamlBox.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace';
        yamlBox.style.tabSize = '2';
        yamlWrap.appendChild(yamlLabel);
        // Mismatch panel above textarea
        const mismatchPanel = document.createElement('div');
        mismatchPanel.style.margin = '4px 0 8px';
        mismatchPanel.style.display = 'none';
        const mmHeader = document.createElement('div');
        mmHeader.style.fontWeight = '600';
        const mmList = document.createElement('div');
        mmList.id = 'mismatchList';
        mmList.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace';
        mmList.style.whiteSpace = 'pre-wrap';
        mmList.style.margin = '4px 0';
        const mmBtn = document.createElement('button');
        mmBtn.type = 'button';
        mmBtn.disabled = true;
        mismatchPanel.appendChild(mmHeader);
        mismatchPanel.appendChild(mmList);
        mismatchPanel.appendChild(mmBtn);
        yamlWrap.appendChild(mismatchPanel);
        const dlBtn = document.createElement('button');
        dlBtn.type = 'button';
        dlBtn.style.margin = '0 0 8px 0';
        const vscode = getVsCodeApi();
        const isJa = (navigator.language || '').toLowerCase().startsWith('ja');
        if (vscode) {
          dlBtn.textContent = isJa ? 'sketch.yaml に反映' : 'Apply to sketch.yaml';
          dlBtn.addEventListener('click', () => {
            const content = yamlBox.value || '';
            if (content) vscode.postMessage({ type: 'applyYaml', yaml: content });
          });
        } else {
          dlBtn.textContent = 'Download sketch.yaml';
          dlBtn.addEventListener('click', () => {
            const content = yamlBox.value || '';
            const blob = new Blob([content], { type: 'text/yaml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sketch.yaml';
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
          });
        }
        yamlWrap.appendChild(dlBtn);
        yamlWrap.appendChild(yamlBox);
        root.appendChild(yamlWrap);

        // If there is an initial profile block (from existing sketch.yaml), inject it immediately
        // to avoid showing a temporary template and to preserve unknown keys like `note`.
        try {
          const initialBlock = String(window.__INITIAL_PROFILE_BLOCK__ || '');
          const profNameHint = String(window.__PROFILE_NAME__ || '');
          if (initialBlock.trim()) {
            const wrapped = 'profiles:\n' + initialBlock.replace(/\s+$/, '') + '\n\n' + (profNameHint ? ('default_profile: ' + profNameHint + '\n') : '');
            yamlBox.value = wrapped;
            window.__KEEP_EXISTING_YAML__ = true;
            // Avoid patching libraries until the user explicitly changes selection
            window.__ALLOW_LIB_PATCH__ = false;
            // Update FQBN summaries to ext, but do not rebuild YAML
            try { summaryTop.textContent = extFqbn || fqbn; summaryBottom.textContent = extFqbn || fqbn; } catch (_) { }
          }
        } catch (_) { }

        const opts = Array.isArray(detail.config_options) ? detail.config_options : [];
        if (!opts.length) {
          const p = document.createElement('p');
          p.className = 'empty';
          p.textContent = 'This board has no config_options.';
          root.appendChild(p);
          // Show base FQBN in both places even without options
          summaryTop.textContent = `${fqbn}`;
          summaryBottom.textContent = `${fqbn}`;
          // Note: do NOT return here so that mismatch panel
          // and the update button are still active and can
          // update the YAML template (e.g., platform version).
        }

        const groups = [];
        // Track selected platform version; prefer version from sketch.yaml init if provided
        let selectedPlatformVersion = (function () {
          try {
            const init = window.__INIT_STATE__ || {};
            const initVer = init.platformVersion || '';
            if (initVer) return initVer;
          } catch (_) { }
          return (detail && typeof detail.version === 'string' && detail.version) ? detail.version : '';
        })();
        opts.forEach((opt, idx) => {
          const groupName = `opt_${idx}`;
          const fs = document.createElement('fieldset');
          fs.style.margin = '12px 0';
          const legend = document.createElement('legend');
          const optionKey = (opt && (opt.option || opt.id || `option_${idx + 1}`));
          const optionLabel = (opt && (opt.option_label || opt.label || optionKey));
          legend.textContent = String(optionLabel);
          fs.appendChild(legend);

          const values = (opt && Array.isArray(opt.values)) ? opt.values : [];
          // Determine default index (prefer is_default; fallback to 0)
          let defaultIdx = 0;
          for (let j = 0; j < values.length; j++) {
            if (values[j] && values[j].is_default) { defaultIdx = j; break; }
          }
          values.forEach((v, j) => {
            const id = `${groupName}_${j}`;
            const wrap = document.createElement('div');
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = groupName;
            input.id = id;
            const valText = (v && (v.value ?? v.id ?? v.label ?? '')) + '';
            const valLabel = (v && (v.value_label ?? v.label ?? valText)) + '';
            input.value = valText;
            if (v && v.is_default) input.checked = true;
            input.dataset.groupIndex = String(idx);
            input.dataset.index = String(j);
            input.dataset.option = String(optionKey);
            input.dataset.valText = valText;
            const lab = document.createElement('label');
            lab.htmlFor = id;
            lab.textContent = valLabel + (v && v.is_default ? ' (default)' : '');
            wrap.appendChild(input);
            wrap.appendChild(lab);
            fs.appendChild(wrap);
          });

          // If none default, select first for clarity
          if (!fs.querySelector('input[type="radio"]:checked')) {
            const first = fs.querySelector('input[type="radio"]');
            if (first) first.checked = true;
          }

          // Store default index on fieldset for later comparisons
          fs.dataset.defaultIndex = String(defaultIdx);

          root.appendChild(fs);
          groups.push(fs);
        });

        function toSlug(s) {
          return (s || '').toLowerCase().replace(/[^a-z0-9_]+/g, '_').replace(/^_+|_+$/g, '') || 'default';
        }
        function buildYaml(extFqbn) {
          const parts = fqbn.split(':');
          const platformId = parts.length >= 2 ? (parts[0] + ':' + parts[1]) : fqbn;
          const platformVer = selectedPlatformVersion || '';
          // Prefer provided profile name (from sketch.yaml) when available to avoid switching to FQBN-derived name
          const profileHint = (typeof window !== 'undefined' && window.__PROFILE_NAME__) ? String(window.__PROFILE_NAME__) : '';
          const profile = (profileHint && profileHint.trim()) ? profileHint.trim() : toSlug(parts[2] || detail.name || parts[parts.length - 1] || 'profile');
          const lines = [];
          lines.push('profiles:');
          lines.push('  ' + profile + ':');
          lines.push('    fqbn: ' + extFqbn);
          lines.push('    platforms:');
          lines.push('      - platform: ' + platformId + (platformVer ? ` (${platformVer})` : ''));
          if (pkgUrl) {
            lines.push('        platform_index_url: ' + pkgUrl);
          }
          if (selectedLibs.size > 0) {
            lines.push('    libraries:');
            for (const [name, ver] of selectedLibs.entries()) {
              const display = typeof ver === 'string' && ver ? `${name} (${ver})` : name;
              lines.push('      - ' + display);
            }
          }
          lines.push('');
          lines.push('default_profile: ' + profile);
          return lines.join('\n');
        }
        // Patch helpers for keep mode
        function patchFqbnInYaml(yamlText, profileName, extFqbn) {
          try {
            const lines = String(yamlText || '').split(/\r?\n/);
            // Find profiles section bounds
            let pStart = -1; let pEnd = lines.length;
            for (let i = 0; i < lines.length; i++) {
              if (/^\s*profiles\s*:\s*$/.test(lines[i])) { pStart = i; for (let j = i + 1; j < lines.length; j++) { if (/^\S/.test(lines[j])) { pEnd = j; break; } } break; }
            }
            if (pStart < 0) return yamlText;
            // Find profile block
            let profStart = -1; let profEnd = pEnd;
            const wanted = String(profileName || '').trim();
            for (let i = pStart + 1; i < pEnd; i++) {
              const m = lines[i].match(/^\s{2}([^\s:#][^:]*)\s*:\s*$/);
              if (m) {
                if (!wanted || m[1].trim() === wanted) {
                  if (profStart < 0) { profStart = i; continue; }
                }
                if (profStart >= 0) { profEnd = i; break; }
              }
            }
            if (profStart < 0) return yamlText;
            if (profEnd <= profStart) profEnd = pEnd;
            // Look for fqbn line, else insert right after profile key
            let fqbnLine = -1;
            for (let i = profStart + 1; i < profEnd; i++) {
              if (/^\s{4}fqbn\s*:\s*.+$/.test(lines[i])) { fqbnLine = i; break; }
              // stop if next sibling key at same indent appears
              if (/^\s{2}[^\s:#][^:]*\s*:\s*$/.test(lines[i])) break;
            }
            if (fqbnLine >= 0) {
              lines[fqbnLine] = `    fqbn: ${extFqbn}`;
              return lines.join('\n');
            }
            // Insert after the profile key line
            const before = lines.slice(0, profStart + 1).join('\n');
            const after = lines.slice(profStart + 1).join('\n');
            const mid = `\n    fqbn: ${extFqbn}`;
            return before + mid + (after.startsWith('\n') ? '' : '\n') + after;
          } catch (_) { return yamlText; }
        }
        function libsArrayFromSelected() {
          const arr = [];
          for (const [name, ver] of selectedLibs.entries()) {
            arr.push({ name, version: (typeof ver === 'string' && ver) ? ver : '' });
          }
          return arr;
        }
        // Helpers to patch only the libraries: section inside the current YAML when preserving existing YAML
        function patchLibrariesInYaml(yamlText, profileName, libs) {
          try {
            const lines = String(yamlText || '').split(/\r?\n/);
            let pStart = -1; let pEnd = lines.length;
            for (let i = 0; i < lines.length; i++) {
              if (/^\s*profiles\s*:\s*$/.test(lines[i])) { pStart = i; for (let j = i + 1; j < lines.length; j++) { if (/^\S/.test(lines[j])) { pEnd = j; break; } } break; }
            }
            if (pStart < 0) return yamlText;
            let profStart = -1; let profEnd = pEnd;
            let profName = String(profileName || '').trim();
            for (let i = pStart + 1; i < pEnd; i++) {
              const m = lines[i].match(/^\s{2}([^\s:#][^:]*)\s*:\s*$/);
              if (m) {
                if (!profName) { profName = m[1].trim(); profStart = i; continue; }
                if (m[1].trim() === profName) { profStart = i; continue; }
                if (profStart >= 0) { profEnd = i; break; }
              }
            }
            if (profStart < 0) return yamlText;
            if (profEnd <= profStart) profEnd = pEnd;
            let libHeader = -1; let libEnd = -1;
            for (let i = profStart + 1; i < profEnd; i++) {
              if (/^\s{4}libraries\s*:\s*$/.test(lines[i])) {
                libHeader = i;
                libEnd = i + 1;
                for (let j = i + 1; j < profEnd; j++) {
                  if (/^\s{6}-\s*/.test(lines[j])) { libEnd = j + 1; continue; }
                  if (/^\s{4}[^\s:#][^:]*\s*:\s*$/.test(lines[j]) || /^\s{2}[^\s:#][^:]*\s*:\s*$/.test(lines[j]) || /^\S/.test(lines[j]) || /^\s*default_profile\s*:\s*/.test(lines[j])) { break; }
                }
                break;
              }
            }
            const formatted = [];
            if (Array.isArray(libs)) {
              for (const entry of libs) {
                const name = entry && entry.name ? String(entry.name).trim() : '';
                if (!name) continue;
                const ver = entry && entry.version ? String(entry.version).trim() : '';
                formatted.push('      - ' + (ver ? name + ' (' + ver + ')' : name));
              }
            }
            const hasLibs = formatted.length > 0;
            if (libHeader >= 0) {
              const beforeArr = lines.slice(0, libHeader);
              const afterArr = lines.slice(libEnd >= 0 ? libEnd : libHeader + 1);
              if (!hasLibs) {
                return beforeArr.concat(afterArr).join('\n').replace(/\n{3,}/g, '\n\n');
              }
              return beforeArr.concat(['    libraries:', ...formatted], afterArr).join('\n');
            }
            if (!hasLibs) return yamlText;
            const beforeArr = lines.slice(0, profEnd);
            const afterArr = lines.slice(profEnd);
            const block = ['    libraries:', ...formatted];
            return beforeArr.concat(block, afterArr).join('\n').replace(/\n{3,}/g, '\n\n');
          } catch (_) { return yamlText; }
        }

        // Patch only the platform version in the current profile's platforms list
        function patchPlatformVersionInYaml(yamlText, profileName, platformId, newVersion) {
          try {
            const id = String(platformId || '').trim();
            const ver = String(newVersion || '').trim();
            if (!id) return yamlText;
            const lines = String(yamlText || '').split(/\r?\n/);
            // Find profiles bounds
            let pStart = -1; let pEnd = lines.length;
            for (let i = 0; i < lines.length; i++) {
              if (/^\s*profiles\s*:\s*$/.test(lines[i])) { pStart = i; for (let j = i + 1; j < lines.length; j++) { if (/^\S/.test(lines[j])) { pEnd = j; break; } } break; }
            }
            if (pStart < 0) return yamlText;
            // Find profile block
            let profStart = -1; let profEnd = pEnd;
            const wanted = String(profileName || '').trim();
            for (let i = pStart + 1; i < pEnd; i++) {
              const m = lines[i].match(/^\s{2}([^\s:#][^:]*)\s*:\s*$/);
              if (m) {
                if (!wanted || m[1].trim() === wanted) {
                  if (profStart < 0) { profStart = i; continue; }
                }
                if (profStart >= 0) { profEnd = i; break; }
              }
            }
            if (profStart < 0) return yamlText;
            if (profEnd <= profStart) profEnd = pEnd;
            const desired = `      - platform: ${id}${ver ? ` (${ver})` : ''}`;
            // Look for platforms header
            let platsHeader = -1;
            for (let i = profStart + 1; i < profEnd; i++) {
              if (/^\s{4}platforms\s*:\s*$/.test(lines[i])) { platsHeader = i; break; }
            }
            if (platsHeader >= 0) {
              // Search for matching platform entry to replace; else insert after header
              for (let i = platsHeader + 1; i < profEnd; i++) {
                const line = lines[i];
                if (/^\s{6}-\s*platform\s*:\s*/.test(line)) {
                  const m = line.match(/^\s{6}-\s*platform\s*:\s*([^\s]+)\s*(?:\([^)]*\))?\s*$/);
                  if (m && m[1] === id) {
                    lines[i] = desired;
                    return lines.join('\n');
                  }
                  continue;
                }
                // stop when another key at same indent or profile ends
                if (/^\s{4}[^\s:#][^:]*\s*:\s*$/.test(line) || /^\s{2}[^\s:#][^:]*\s*:\s*$/.test(line) || /^\S/.test(line) || /^\s*default_profile\s*:\s*/.test(line)) {
                  break;
                }
              }
              // Not found: insert after header
              const before = lines.slice(0, platsHeader + 1).join('\n');
              const after = lines.slice(platsHeader + 1).join('\n');
              return before + '\n' + desired + (after.startsWith('\n') ? '' : '\n') + after;
            }
            // No platforms header: insert a minimal block after profile key
            const before = lines.slice(0, profStart + 1).join('\n');
            const after = lines.slice(profStart + 1).join('\n');
            const block = ['    platforms:', desired].join('\n');
            return [before, block, after].join('\n');
          } catch (_) { return yamlText; }
        }
        function updateSummary() {
          // Skip templating before init finishes to avoid wiping existing YAML
          try { if (window.__INIT_PENDING__) { return; } } catch (_) { }
          // Inject existing profile YAML on first pass to preserve unknown keys
          try {
            const hasInitial = !!(String(window.__INITIAL_PROFILE_BLOCK__ || '').trim());
            if (hasInitial && !window.__KEEP_EXISTING_YAML__) {
              const box = document.getElementById('yamlBox');
              if (box) {
                const profNameHint = String(window.__PROFILE_NAME__ || '').trim();
                const wrapped = 'profiles:\n' + String(window.__INITIAL_PROFILE_BLOCK__).replace(/\s+$/, '') + '\n\n' + (profNameHint ? ('default_profile: ' + profNameHint + '\n') : '');
                box.value = wrapped;
                window.__KEEP_EXISTING_YAML__ = true;
                if (!window.__CURRENT_EXTFQBN__) window.__CURRENT_EXTFQBN__ = fqbn;
                try { summaryTop.textContent = fqbn; summaryBottom.textContent = fqbn; } catch (_) { }
                return;
              }
            }
          } catch (_) { }
          // Gather selected values across groups
          const pairs = [];
          let anyChanged = false;
          groups.forEach((fs) => {
            const sel = fs.querySelector('input[type="radio"]:checked');
            if (!sel) return;
            const opt = sel.dataset.option || '';
            const val = sel.dataset.valText || '';
            const idx = Number(sel.dataset.index || '0');
            const def = Number(fs.dataset.defaultIndex || '0');
            if (idx !== def) {
              anyChanged = true;
              pairs.push(`${opt}=${val}`);
            }
          });
          const ext = (pairs.length && anyChanged) ? `${fqbn}:${pairs.join(',')}` : `${fqbn}`;
          if (pairs.length && anyChanged) {
            const text = ext;
            summaryTop.textContent = text;
            summaryBottom.textContent = text;
          } else {
            summaryTop.textContent = `${fqbn}`;
            summaryBottom.textContent = `${fqbn}`;
          }
          // If base FQBN (vendor:arch:board) changed by user, unlock keep-mode and reset everything to template
          try {
            const prev = String(window.__CURRENT_EXTFQBN__ || '');
            const userChanged = !!window.__USER_CHANGED_OPTIONS__;
            if (ext !== prev) {
              window.__CURRENT_EXTFQBN__ = ext;
              // Compare base FQBNs: only reset when base board changed, not when only options changed
              const baseNow = String(fqbn || '');
              const basePrev = String(window.__CURRENT_BASEFQBN__ || '');
              const baseChanged = baseNow !== basePrev;
              if (baseChanged) {
                try { window.__CURRENT_BASEFQBN__ = baseNow; } catch (_) { }
              }
              if (userChanged && baseChanged) {
                // Unlock and clear initial preserved state
                window.__KEEP_EXISTING_YAML__ = false;
                window.__INITIAL_PROFILE_BLOCK__ = '';
                window.__PROFILE_NAME__ = '';
                // Reset libraries selection
                try { selectedLibs.clear(); } catch (_) { }
                // Reset library UI filters so items appear
                try { if (typeof onlySel !== 'undefined' && onlySel) onlySel.checked = false; } catch (_) { }
                try { if (typeof libsQ !== 'undefined' && libsQ) libsQ.value = ''; } catch (_) { }
                // Rebuild YAML from template for the new FQBN
                yamlBox.value = buildYaml(ext);
                try { renderLibs(); } catch (_) { }
                try { updateMismatches(); } catch (_) { }
                return;
              }
            }
          } catch (_) { }
          // Respect preserve flag: don't overwrite textarea when using existing profile block
          try {
            const keep = !!window.__KEEP_EXISTING_YAML__;
            if (!keep) {
              yamlBox.value = buildYaml(ext);
            } else {
              // Patch FQBN always; patch libraries only after user interaction to avoid wiping existing entries
              const libsArr = libsArrayFromSelected();
              const prof = (window.__PROFILE_NAME__ || '');
              let txt = patchFqbnInYaml(yamlBox.value, prof, ext);
              if (window.__ALLOW_LIB_PATCH__) {
                txt = patchLibrariesInYaml(txt, prof, libsArr);
              }
              yamlBox.value = txt;
            }
          } catch (_) {
            yamlBox.value = buildYaml(ext);
          }
        }

        // Apply extFqbn option pairs (if any) with retries to avoid timing issues
        (function scheduleApplyOptionPairs() {
          const delays = [0, 50, 150, 400];
          const esc = (s) => { try { return (window.CSS && CSS.escape) ? CSS.escape(s) : s.replace(/[^a-zA-Z0-9_-]/g, '\\$&'); } catch (_) { return s; } };
          function applyOnce() {
            try {
              const pairs = Array.isArray(window.__OPT_PAIRS) ? window.__OPT_PAIRS : null;
              if (!pairs || !pairs.length) return;
              const rootEl = document.getElementById('config');
              pairs.forEach(({ key, val }) => {
                const selector = `#config input[type="radio"][data-option="${esc(key)}"][data-val-text="${esc(val)}"]`;
                const input = rootEl && rootEl.querySelector(selector);
                if (input) {
                  input.checked = true;
                  input.dispatchEvent(new Event('change', { bubbles: true }));
                }
              });
            } catch (_) { /* ignore */ }
          }
          delays.forEach(d => setTimeout(applyOnce, d));
        })();

        // Hook change events
        groups.forEach((fs) => {
          fs.addEventListener('change', () => {
            try {
              // Ignore synthetic changes during init
              if (window.__INIT_PENDING__) { updateSummary(); return; }
              window.__USER_CHANGED_OPTIONS__ = true;
            } catch (_) { }
            updateSummary();
          });
        });

        // Libraries UI (under options)
        const libsWrap = document.createElement('div');
        libsWrap.style.margin = '12px 0';
        const libsHeader = document.createElement('div');
        libsHeader.textContent = 'Libraries';
        libsHeader.style.fontWeight = '600';
        libsHeader.style.margin = '8px 0 4px';
        const libsControls = document.createElement('div');
        libsControls.className = 'controls';
        const libsQ = document.createElement('input');
        libsQ.type = 'search';
        libsQ.placeholder = 'Filter libraries (partial match)';
        libsQ.autocomplete = 'off';
        libsQ.className = 'textbox';
        libsQ.style.flex = '1 1 260px';
        const libsStatus = document.createElement('div');
        libsStatus.id = 'libsStatus';
        libsStatus.style.fontSize = '.92rem';
        libsStatus.style.opacity = '.8';
        libsStatus.textContent = 'Loading...';
        libsControls.appendChild(libsQ);
        const onlySel = document.createElement('input');
        onlySel.type = 'checkbox';
        onlySel.id = 'onlySelected';
        onlySel.style.marginLeft = '8px';
        const onlySelLabel = document.createElement('label');
        onlySelLabel.htmlFor = 'onlySelected';
        onlySelLabel.textContent = 'Only selected';
        onlySelLabel.style.marginLeft = '4px';
        libsControls.appendChild(onlySel);
        libsControls.appendChild(onlySelLabel);
        libsControls.appendChild(libsStatus);
        const libsList = document.createElement('ul');
        libsList.id = 'libsList';
        libsList.style.marginTop = '8px';
        libsWrap.appendChild(libsHeader);
        libsWrap.appendChild(libsControls);
        libsWrap.appendChild(libsList);
        root.appendChild(libsWrap);

        function libName(row) { return (row.name || row.Title || row.title || row.Library || '').toString(); }
        function libVersion(row) { return (row.version || row.Version || row.library_version || '').toString(); }

        function findLatestVersionByName(targetName) {
          if (!Array.isArray(libsCache)) return '';
          for (const row of libsCache) {
            if (libName(row) === targetName) return libVersion(row) || '';
          }
          return '';
        }
        function collectVersionMismatches() {
          const mismatches = [];
          for (const [name, ver] of selectedLibs.entries()) {
            if (typeof ver !== 'string' || !ver) continue; // only when YAML specified a version
            const latest = findLatestVersionByName(name);
            if (latest && latest !== ver) {
              mismatches.push({ name, current: ver, latest });
            }
          }
          return mismatches;
        }
        function renderLibs() {
          libsList.innerHTML = '';
          if (!Array.isArray(libsCache)) { libsStatus.textContent = 'Load error'; return; }
          // No implicit default library selection; respect only provided/selected libraries
          const term = libsQ.value.trim().toLowerCase();
          let visible = 0;
          libsCache.forEach((row, idx) => {
            const name = libName(row);
            const ver = libVersion(row);
            const text = (name + ' ' + ver).toLowerCase();
            if (term && !text.includes(term)) return;
            if (onlySel.checked && !selectedLibs.has(name)) return;
            const li = document.createElement('li');
            const id = 'lib_' + idx;
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.id = id;
            cb.checked = selectedLibs.has(name);
            cb.addEventListener('change', () => {
              if (cb.checked) { selectedLibs.set(name, ver ? ver : ''); } else { selectedLibs.delete(name); }
              // User interacted with libraries; allow YAML libraries patching from now on
              try { window.__ALLOW_LIB_PATCH__ = true; } catch (_) { }
              updateSummary();
              try { updateMismatches(); } catch (_) { }
            });
            const lab = document.createElement('label');
            lab.htmlFor = id;
            lab.textContent = ver ? `${name} (${ver})` : name;
            li.appendChild(cb);
            li.appendChild(lab);
            libsList.appendChild(li);
            visible++;
          });
          libsStatus.textContent = `${visible} item(s)`;
          try { updateMismatches(); } catch (_) { }
        }
        libsQ.addEventListener('input', renderLibs);
        onlySel.addEventListener('change', renderLibs);
        if (libsCache === null) {
          fetch(LIB_URL + '?v=' + Date.now(), { cache: 'no-store' })
            .then(r => { if (!r.ok) throw new Error('HTTP ' + r.status); return r.json(); })
            .then(json => {
              libsCache = Array.isArray(json) ? json : [];
              // No implicit default library selection
              renderLibs();
              updateSummary();
              // In case options UI got re-rendered after libs, apply pairs again
              setTimeout(() => {
                try {
                  const pairs = Array.isArray(window.__OPT_PAIRS) ? window.__OPT_PAIRS : null;
                  if (!pairs || !pairs.length) return;
                  const rootEl = document.getElementById('config');
                  const esc = (s) => { try { return (window.CSS && CSS.escape) ? CSS.escape(s) : s.replace(/[^a-zA-Z0-9_-]/g, '\\$&'); } catch (_) { return s; } };
                  pairs.forEach(({ key, val }) => {
                    const selector = `#config input[type=\"radio\"][data-option=\"${esc(key)}\"][data-val-text=\"${esc(val)}\"]`;
                    const input = rootEl && rootEl.querySelector(selector);
                    if (input) { input.checked = true; input.dispatchEvent(new Event('change', { bubbles: true })); }
                  });
                } catch (_) { }
              }, 50);
            })
            .catch(() => { libsCache = []; renderLibs(); });
        } else {
          // No implicit default library selection
          renderLibs();
          setTimeout(() => { try { const pairs = Array.isArray(window.__OPT_PAIRS) ? window.__OPT_PAIRS : null; if (!pairs || !pairs.length) return; const rootEl = document.getElementById('config'); const esc = (s) => { try { return (window.CSS && CSS.escape) ? CSS.escape(s) : s.replace(/[^a-zA-Z0-9_-]/g, '\\$&'); } catch (_) { return s; } }; pairs.forEach(({ key, val }) => { const selector = `#config input[type=\"radio\"][data-option=\"${esc(key)}\"][data-val-text=\"${esc(val)}\"]`; const input = rootEl && rootEl.querySelector(selector); if (input) { input.checked = true; input.dispatchEvent(new Event('change', { bubbles: true })); } }); } catch (_) { } }, 50);
        }

        // Initial render
        updateSummary();
        try { updateMismatches(); } catch (_) { }

        // Helpers to compute mismatches and update the mismatch panel
        function findLatestVersionByName(targetName) {
          if (!Array.isArray(libsCache)) return '';
          for (const row of libsCache) { if (libName(row) === targetName) return libVersion(row) || ''; }
          return '';
        }
        function collectLibVersionMismatches() {
          const mismatches = [];
          for (const [name, ver] of selectedLibs.entries()) {
            const current = (typeof ver === 'string') ? ver.trim() : '';
            const latest = findLatestVersionByName(name);
            if (!latest) continue;
            if (!current || current !== latest) {
              mismatches.push({ type: 'lib', name, current, latest });
            }
          }
          return mismatches;
        }
        function collectPlatformMismatch() {
          try {
            const init = window.__INIT_STATE__ || {};
            const initId = init.platformId || '';
            const initVer = typeof init.platformVersion === 'string' ? init.platformVersion : '';
            const parts = fqbn.split(':');
            const platformId = parts.length >= 2 ? (parts[0] + ':' + parts[1]) : fqbn;
            const latestVer = (detail && typeof detail.version === 'string') ? detail.version : '';
            if (!initId || !platformId || initId !== platformId) return null;
            if (!latestVer) return null;
            if (!initVer) {
              return { type: 'platform', name: platformId, current: '', latest: latestVer };
            }
            if (initVer !== latestVer) {
              return { type: 'platform', name: platformId, current: initVer, latest: latestVer };
            }
          } catch (_) { }
          return null;
        }
        function updateMismatches() {
          const ja = (navigator.language || '').toLowerCase().startsWith('ja');
          const platformMM = collectPlatformMismatch();
          const libMM = collectLibVersionMismatches();
          const lines = [];
          if (platformMM) {
            const currentLabel = platformMM.current ? platformMM.current : (ja ? '\u672a\u6307\u5b9a' : 'Unspecified');
            const latestLabel = platformMM.latest ? platformMM.latest : (ja ? '\u6700\u65b0' : 'Latest');
            lines.push((ja ? '\u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0' : 'Platform') + ` ${platformMM.name}: ${currentLabel} -> ${latestLabel}`);
          }
          libMM.forEach(m => {
            const currentLabel = m.current ? m.current : (ja ? '\u672a\u6307\u5b9a' : 'Unspecified');
            const latestLabel = m.latest ? m.latest : (ja ? '\u6700\u65b0' : 'Latest');
            lines.push(`${m.name}: ${currentLabel} -> ${latestLabel}`);
          });
          mmList.textContent = lines.join('\n');
          const count = lines.length;
          mmHeader.textContent = ja ? '\u66f4\u65b0\u53ef\u80fd\u306a\u9805\u76ee' : 'Updates available';
          mmBtn.textContent = (ja ? '最新に更新' : 'Update to latest') + (count ? ` (${count})` : '');
          mmBtn.disabled = count === 0;
          mismatchPanel.style.display = count ? '' : 'none';
        }
        mmBtn.addEventListener('click', () => {
          const ja = (navigator.language || '').toLowerCase().startsWith('ja');
          // Update libraries to latest
          const libMM = collectLibVersionMismatches();
          libMM.forEach(({ name, latest }) => { if (latest) selectedLibs.set(name, latest); });
          // Ask for platform update when mismatch exists
          const plat = collectPlatformMismatch();
          if (plat) {
            // Apply platform update without confirmation for consistency with library updates
            selectedPlatformVersion = plat.latest;
            try { (window.__INIT_STATE__ = window.__INIT_STATE__ || {}).platformVersion = plat.latest; } catch (_) { }
          }
          renderLibs();
          // User explicitly requested updates: allow libraries patching into YAML
          try { window.__ALLOW_LIB_PATCH__ = true; } catch (_) { }
          updateSummary();
          // Update platform version in YAML textarea (even in keep mode), but scoped to the current profile only
          try {
            const parts = fqbn.split(':');
            const platformId = parts.length >= 2 ? (parts[0] + ':' + parts[1]) : fqbn;
            const prof = (window.__PROFILE_NAME__ || '');
            yamlBox.value = patchPlatformVersionInYaml(yamlBox.value, prof, platformId, selectedPlatformVersion);
          } catch (_) { }
          updateMismatches();
        });
      }

      const handleFilterTrigger = () => {
        try { if (!window.__INIT_PENDING__) window.__USER_CHANGED_OPTIONS__ = true; } catch (_) { }
        applyFilter();
      };
      q.addEventListener('input', handleFilterTrigger);
      q.addEventListener('change', handleFilterTrigger);
      q.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') {
          try { if (!window.__INIT_PENDING__) window.__USER_CHANGED_OPTIONS__ = true; } catch (_) { }
          applyFilter();
        }
      });

      // Load data
      fetch(DATA_URL + '?v=' + Date.now(), { cache: 'no-store' })
        .then(resp => {
          if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
          return resp.json();
        })
        .then(json => {
          render(json);
          applyFilter();
        })
        .catch(err => {
          list.innerHTML = '';
          const li = document.createElement('li');
          li.className = 'empty';
          li.textContent = 'Could not load data. Please run run.php first.';
          list.appendChild(li);
          setStatus(`Load error: ${err.message}`, true);
        });

      // VS Code integration: preselect board options and libraries from current profile
      window.addEventListener('message', (ev) => {
        const data = ev && ev.data || {};
        if (!data || data.type !== 'init') return;
        try {
          // Store initial platform info
          window.__INIT_STATE__ = { platformId: String(data.platformId || ''), platformVersion: String(data.platformVersion || '') };
          // If a raw profile block is provided, remember it and try to inject into textarea later
          try { window.__INITIAL_PROFILE_BLOCK__ = (typeof data.profileBlock === 'string') ? data.profileBlock : ''; } catch (_) { }
          try { window.__PROFILE_NAME__ = String(data.profileName || ''); } catch (_) { }
          try { window.__INIT_EXTFQBN__ = String(data.extFqbn || ''); window.__CURRENT_EXTFQBN__ = window.__INIT_EXTFQBN__; } catch (_) { }
          const extFqbn = String(data.extFqbn || '');
          if (!extFqbn) return;
          // Base FQBN is vendor:arch:board (first 3 segments)
          const parts = extFqbn.split(':');
          const baseFqbn = parts.slice(0, 3).join(':');
          const pairsText = parts.slice(3).join(':');
          q.value = baseFqbn;
          try { window.__CURRENT_BASEFQBN__ = baseFqbn; } catch (_) { }
          applyFilter();
          // Schedule additional retries after filter-triggered re-render
          setTimeout(() => {
            try {
              const pairs = Array.isArray(window.__OPT_PAIRS) ? window.__OPT_PAIRS : null;
              if (!pairs || !pairs.length) return;
              const rootEl = document.getElementById('config');
              const esc = (s) => { try { return (window.CSS && CSS.escape) ? CSS.escape(s) : s.replace(/[^a-zA-Z0-9_-]/g, '\\$&'); } catch (_) { return s; } };
              pairs.forEach(({ key, val }) => {
                const selector = `#config input[type=\"radio\"][data-option=\"${esc(key)}\"][data-val-text=\"${esc(val)}\"]`;
                const input = rootEl && rootEl.querySelector(selector);
                if (input) { input.checked = true; input.dispatchEvent(new Event('change', { bubbles: true })); }
              });
            } catch (_) { }
          }, 100);
          // After giving the UI time to render and initial YAML to inject, lift the init guard
          setTimeout(() => { try { window.__INIT_PENDING__ = false; updateSummary(); } catch (_) { } }, 220);

          // If initial profile YAML was provided, inject it into the textarea after UI renders
          const tryInjectYaml = () => {
            try {
              const box = document.getElementById('yamlBox');
              // Do not trim leading spaces to preserve YAML indentation
              const raw = String(window.__INITIAL_PROFILE_BLOCK__ || '').replace(/\s+$/, '');
              const profName = String(data.profileName || '').trim();
              if (box && raw) {
                const wrapped = 'profiles:\n' + raw.replace(/\s+$/, '') + '\n\n' + (profName ? ('default_profile: ' + profName + '\n') : '');
                box.value = wrapped;
                // Lock auto-template updates to preserve the injected YAML block
                try { window.__KEEP_EXISTING_YAML__ = true; } catch (_) { }
                // Update summary display to reflect extFqbn but avoid overwriting YAML
                const top = document.querySelector('#config .fqbn');
                const bottom = document.getElementById('summaryBottom');
                if (top) top.textContent = extFqbn;
                if (bottom) bottom.textContent = extFqbn;
              }
            } catch (_) { /* ignore */ }
          };
          // Attempt a few times to ensure elements exist
          [50, 150, 350].forEach(d => setTimeout(tryInjectYaml, d));
          // Parse and store option selections for application after config renders
          window.__OPT_PAIRS = null;
          if (pairsText) {
            const pairs = [];
            pairsText.split(',').map(s => s.trim()).filter(Boolean).forEach(p => {
              const kv = p.split('=');
              if (kv.length < 2) return;
              const key = kv[0];
              const val = kv.slice(1).join('=');
              pairs.push({ key, val });
            });
            if (pairs.length) window.__OPT_PAIRS = pairs;
          }
          // Apply libraries selection
          if (Array.isArray(data.libraries)) {
            selectedLibs.clear();
            data.libraries.forEach(row => {
              const name = (row && row.name) ? String(row.name) : '';
              const ver = (row && row.version) ? String(row.version) : '';
              if (name) selectedLibs.set(name, ver ? ver : '');
            });
            // If library list already loaded, re-render and update summary
            try { if (libsCache !== null) { renderLibs(); } } catch (_) { }
            // Avoid overwriting provided YAML block; only refresh mismatches/summary text
            try {
              const hadInitial = !!(window.__INITIAL_PROFILE_BLOCK__);
              if (!hadInitial) updateSummary();
            } catch (_) { }
            try { if (typeof updateMismatches === 'function') updateMismatches(); } catch (_) { }
          }
        } catch (_) { /* ignore */ }
      });
    })();
  </script>
</body>

</html>